# -*- coding: utf-8 -*-
"""통역개시지연시간.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iXDXYJz07mFhJexA3Q1HGWZmMgvW8Kfj
"""

!pip install pydub
!pip install SpeechRecognition

from pydub import AudioSegment
from pydub.utils import db_to_float
from pydub.silence import detect_silence
from pydub.silence import detect_leading_silence
import itertools

# load audio file
audio_path = "sample.wav"
audio_file = AudioSegment.from_wav(audio_path)
audio_file.dBFS

len(audio_file) # full length of audio file

"""# normalization"""

def match_target_amplitude(sound, target_dBFS):
       change_in_dBFS = target_dBFS - sound.dBFS
       return sound.apply_gain(change_in_dBFS)

normalized_audio = match_target_amplitude(audio_file, -20.0)

normalized_audio.dBFS

"""# 1. detect_silence()
pydub의 내장함수 detect_silence()를 일부 수정하여 **사용자의 발화가 시작하기 전** 침묵의 길이만을 return하도록 하였다. 사용자의 발화가 침묵 없이 바로 시작하는 경우에는 0을 return한다.
"""

def detect_silence(audio_segment, min_silence_len=1000, silence_thresh=-16, seek_step=1):
    seg_len = len(audio_segment)

    # you can't have a silent portion of a sound that is longer than the sound
    if seg_len < min_silence_len:
        return []

    # convert silence threshold to a float value (so we can compare it to rms)
    silence_thresh = db_to_float(silence_thresh) * audio_segment.max_possible_amplitude

    # find silence and add start and end indicies to the to_cut list
    silence_starts = []

    # check successive (1 sec by default) chunk of sound for silence
    # try a chunk at every "seek step" (or every chunk for a seek step == 1)
    last_slice_start = seg_len - min_silence_len
    slice_starts = range(0, last_slice_start + 1, seek_step)

    # guarantee last_slice_start is included in the range
    # to make sure the last portion of the audio is searched
    if last_slice_start % seek_step:
        slice_starts = itertools.chain(slice_starts, [last_slice_start])

    for i in slice_starts:
        audio_slice = audio_segment[i:i + min_silence_len]
        if audio_slice.rms <= silence_thresh:
            silence_starts.append(i)
        else: # 첫 번째 nonsilence가 나오면 종료
          break

    # short circuit when there is no silence
    if not silence_starts:
        return []

    # combine the silence we detected into ranges (start ms - end ms)
    silent_ranges = []

    prev_i = silence_starts.pop(0)
    current_range_start = prev_i

    for silence_start_i in silence_starts:
        continuous = (silence_start_i == prev_i + seek_step)

        # sometimes two small blips are enough for one particular slice to be
        # non-silent, despite the silence all running together. Just combine
        # the two overlapping silent ranges.
        silence_has_gap = silence_start_i > (prev_i + min_silence_len)

        if not continuous and silence_has_gap:
            silent_ranges.append([current_range_start,
                                  prev_i + min_silence_len])
            current_range_start = silence_start_i
        prev_i = silence_start_i
    
    if (current_range_start == 0): # 첫 번째 nonsilence 전에 침묵이 존재하는 경우
      return prev_i + min_silence_len
    else: # 첫 번째 nonsilence 전에 침묵이 존재하자 않는 경우
      return 0

first_silence = detect_silence(
    # Use the loaded audio
    normalized_audio,

    # must be silent for at least half a second
    min_silence_len = 500,

    # consider it silent if quieter than -32 dBFS
    silence_thresh = -32

) # length of first silence

print('통역 개시 지연시간 :', first_silence/1000, '초')

"""# 2. detect_leading_silence()
pydub의 내장함수 detect_leading_silence()를 이용하여 첫 번째 침묵의 길이를 구하였다.  
앞에서 detect_silence()를 실행할 때와 threshold를 동일하게 했는데 결과가 다르게 출력되었다.   
- 예상 원인 1. detect_silence()는 rms 값을 이용하는 반면 detect_leading_silence()는 dBFS 값을 이용한다.  
(참고 : https://github.com/jiaaro/pydub/blob/master/pydub/silence.py)

결과 분석 및 정확도 비교를 통해 둘 중 하나를 골라 사용해야 할 것 같다.
"""

leading_silence = detect_leading_silence(
    
    # Use the loaded audio
    normalized_audio,

    # consider it silent if quieter than -32 dBFS
    silence_threshold = -32,

    # must be silent for at least 10ms
    chunk_size = 10
)

print('통역 개시 지연시간 :', leading_silence/1000, '초')

